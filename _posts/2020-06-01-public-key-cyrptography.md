---

layout: post

title: An Introduction to Number Theory for Asymmetric Cryptography

category: Computer Science

excerpt_separator:  <!--more-->

comments: true

---

Public key cryptography is mathematically based in number theory, specifically prime number theory and modular arithmatic. These subfields account for a small, but important, slice of number theory as a whole. This article walks through the key mathematical details of public key cryptography and focuses on specific applications, such as plain RSA, OAEP-RSA, and hybrid encryption. 

<!--more-->

The goal of this post is to provide the mathematical framework for understanding public key encryption from a theoretical perspective. Admittedly, some of the sections are fairly dry, but the ability to describe groups and find inverses is central to the asymmetric encryption process - so it is very important to formally define these concepts. 

## Modular Arithmatic [^1]

Modular arithmatic is defined on discrete sets of integers for a fixed N. The set, $\mathbb{Z}_N$, is defined as $\{0, 1, 2, ...., N-1\}$, which has the property:
$$
N \pmod N = 0 \pmod N,
$$
  or, more generally:
$$
a \pmod N = b \pmod N,
$$
if N divides b-a. 

Basic algebraic structure can be applied to discrete sets that have defined operations, such as modular addition and multiplication. Specifically, groups, rings, and fields can be formed under certain conditions. A group is defined as a set with a single operation that:

1. is closed ($a \cdot b \in \mathbb{Z}_N \forall a, b \in \mathbb{Z}_N$)
2. has an identity ($a \cdot 1 = a$)
3. is associative ($(a \cdot b) \cdot c = a \cdot (b \cdot c)$)
4. has an inverse ($a \cdot a^{-1} = 1 \forall a \in \mathbb{Z}_N$)
5. is commutative - *abelian only* ($a \cdot b = b \cdot a$)

The final condition applies to abelian (commutative) groups, which describes most useful groups in cryptography. A *ring* satisfies the above conditions for two operations (i.e. multiplication and addition), although it is not commutative in multiplication. A *field* satisfies all conditions, and is sometimes referred to as a commutative ring. An example of a *non*-commutative ring is the set of $N \times N$ matrices. An example of a comutative ring, or field, is the set of real numbers ($\mathbb{R}$). 

Certain abelian groups are *cyclic* if they contain a generator. The generator concept is paramount to most asymmetric cryptographic schemes. A generator, $g$, can generate every element in the group with repeated applications of the group operation. In the case of multiplication: 
$$
h = g^x \forall h \in G
$$
Note, the order of the group generated by g would be equal to the order of the group, $|G|$. Also, in this setting, repeated multiplication is defined as modular exponentiation, and the inverse operation is defined as the discrete logarithm. Cryptography is predominatly concerned with finite commutative rings, such as a set of integers modulo N (i.e. $\mathbb{Z}_N$). 

## Finite Groups and Prime Numbers [^1]

Of particular interest is finding a multiplicative inverse under $Z_N$, thereby meeting the conditions of a *multiplicative* group:
$$
ax = 1 \pmod N.
$$
In this case, an inverse exists only if $a$ and $N$ are coprime, that is $gcd(a, N) = 1$. If N itself is prime, then every non-zero element in $\mathbb{Z}_N$ has a unique multiplicative inverse, and $Z_N$ forms a finite field under both addition and multiplication. The set of all invertable elements under multiplication in $\mathbb{Z}_N$ is defined as:
$$
\mathbb{Z}_N^* = \{x \in \mathbb{Z}_N: gcd(x, N) = 1\},
$$
and can also be thought of as the set of all elements relatively prime to $N$. In the case where N itself is prime, it includes all elements of $\mathbb{Z}_N$, with the exception of 0:
$$
\mathbb{Z_p^*} = \{1, 2, 3, ...., p-1\}.
$$
$Z_p^*$ forms a subgroup under multiplication. The order of this group is defined as the Euler totient function, $\phi(N)$, and is defined by the prime factorization of N, namely:
$$
\phi(N) = \Pi_{i=1}^n p_i^{e_i-1}(p_i-1),
$$
which reduces to $p-1$ when $N=p$ is prime. 

There are two important facts to point out about $\phi(N)$ and $\mathbb{Z}_N^*$. First, $\phi(N)$ can be computed given the factorization of $N$, and in the case of RSA this can be exploited to break the encryption scheme. Second, for a general group $G$, where the order of $|G|$ is prime, there are $|G|-1$ generators. Moreover, if N is a *safe prime*, so $N = 2q + 1$ where $q$ is prime, then approximately $1/2$ of the elements in the group are generators. It goes without saying that both groups are cyclic in this case. This fact is discussed later when constructing efficient algorithms for finding generators.

A few final important theorems to note in the study of cryptography. 

**Fermat's little theorem** states that:
$$
a^p = a \pmod p,
$$

$$
a^{(p-1)} = 1 \pmod p
$$

for a prime number p. This is the basis of primality testing, which will be important when discussing RSA encryption below. This theorem is a specific case of the more general:

**Euler totient theorem**, which states that:
$$
a^{\phi_p} = 1 \pmod p
$$

$$
a^{\epsilon \pmod{\phi_p}} \pmod p = a^{\epsilon} \pmod p
$$

if $a$ and $p$ are coprime. Fermat's little theorem generalizes to Euler's totient theorem, since for a given prime number, $p$, all elements in $\mathbb{Z}_p^*$ are coprime to $p$, with $\phi(p) = (p-1)$.  

## Legendre Symbols and Quadratic Residues[^1]

As discussed above, $Z_p$ where $p$ is prime forms a finite field. There is an important subgroup that can be leveraged within this field, namely the subgroup of *quadratic residues*. Quadratic residues are solutions to the equation:
$$
x^2 = y^2 \pmod p \\
(x-y)^2(x+y)^2 = 0 \pmod p \\
x = \pm y \pmod p
$$
As standard in algebra, the solution to a quadratic equation has 2 roots. In the case of a modulus, this is also true. However, since the order of a finite field, p, is odd the two solutions will be distinct. Moreover, exactly half of the group will be squares (i.e. equal to $x^2$), which excluding 0 equals $(p-1)/2$ quadratic residues.

Quadratic residues have a Legendre symbol equal to 1, whereas quadratic non-residues have a Legendre Symbol equal to -1. The Legendre Symbol can be computed for any group member via the following formula:
$$
a^{(p-1)/2} \pmod p
$$
The above is fairly isoteric. However, there are practical applications to consider as well. For example, the quadratic residue properties in $\mathbb{Z}_p$ can be exploited in basic public key encryption schemes, such as ElGamal, to break semantic security and distinguish ciphertexts. This is why a strong theoretical understanding of these concepts is so important to constructing a secure encryption scheme. 

## Algorithms and Time Complexity

It is important to take a step back and understand the goal of modern cryptography. Modern cryptography does not strive for perfect security - this lives in the theoretical domain of Shannon security. In fact, a computationally unbounded attacker can break any modern encryption scheme. However, the time scales of these attacks are enormous - taking potentially hundreds of years even with state of the art compute resources. A more technical phrasing is to say that the goal of modern cryptography is both *computational* and *semantic* security. More specifically, an encryption scheme is secure if an attacker can not "break" the scheme within a reasonable amount of time given polynomial resources. Break is defined as either finding the key by brute force or decrypting the ciphertext by leveraging patterns within a large set of ciphertexts or messages (or both).

In order to understand this definition, it is instructive to review the time-complexity of a few relevant algorithms. The table below illustrates the time complexities of a few common algorithms in cryptography. In general, an algorithm is considered "efficient" if it has a polynomial time complexity. 

#### Standard Algorithms

**Table 1. Standard Cyptographic Algorithms and Time Complexities [^2]**

![TimeComplexities](/Users/jacobtutmaher/Desktop/Applied Crytography/notes/basic_complexities.png)

The algorithms above describe the basic mathematical operations in cryptography. $|N|$ stands for the bitwise length of N rather than the actual value, N. The most costly operation is the $MOD-EXP$ function, which takes order-3 running time. Efficient cryptographic schemes, including RSA seek, to keep the $MOD-EXP$ operations to a minimum. It's important to note that the algorithms required to encrypt and decrypt a message are very efficient, given the corresponding paramters; however, **the algorithms required to break the encryption are very inefficient, aiding to the security of the scheme.** 

#### Discrete Logarithm

For every element of a cyclic group $a \in G$ there is a unique exponent $i$ such that $g^i = a$ for a generator $g$. The inverse operation known as the discrete logarithm, $DL$, computes this unique exponent:
$$
Dlog_{g,G}(a) = i
$$
There is no polynomial time algorithm known to compute the discrete logarithm for a given group. The fastest algorithm known for $\mathbb{Z}_p^*$ where $p$ is prime is:
$$
e^{1.92(ln(p))^{1/3}(ln ln(p))^{2/3}}
$$
In the case of cryptography, where p is large, the DL algorithm is inefficient and impractical. Note, for elliptic curve groups the best known algorithm is $\mathcal{O}(\sqrt{N})$, allowing for smaller bitsize numbers to achieve 80 bits of security (160 bits for elliptic curves vs. 1024 bits for $\mathbb{Z}_p^*$) therby making encryption 260x more efficient in elliptic curve groups.

#### Generator Testing

As stated above, if p is a *safe* prime, $p = 2q +1$, then half of the elements in $\mathbb{Z}_p^*$ will be generators. Moreover, if an element $g \in \mathbb{Z}_p^*$ is a generator, then $g^2 \neq 1$ and $g^q \neq 1$ modulo p. These facts help create an efficient algorithm for finding generators in $\mathbb{Z}_p^*$ where p is a safe prime.  For a randomized generator algorithm, only 2 iterations (on average) will need to be conducted. In each loop, two $MOD-EXP$ steps will need to be executed. 

#### Primality Testing

Finding a safe prime consists of selecting numbers within a specified range and testing if they are prime and if $q$, where $p = 2q + 1$, is also prime. While this process seems inefficient, there actually exists both a randomized and deterministic algorithm that can successfully execute these steps in $\mathcal{O}(|N|^3)$. It also turns out that the density of primes, $\pi(N)$ is large enough to make this step efficient. 
$$
Pr[p=prime] = \frac{\pi(p)}{p} \approx \frac{p}{ln(p)},
$$
which for a large prime, p, is approximately $1/1000$. 

#### Factorization

When the numbers are large, no efficient, non-quantum factorization algorithm is know. It turns out that the best known algorithm, the Number Field Sieve, has the same time complexity as the best known discrete logaritm algorithm:
$$
e^{1.92(ln(p))^{1/3}(ln ln(p))^{2/3}}
$$
Note, the time complexity for the best known factoring algorithm is similar to the time complexity for the best known discrete logarithm algorithms due to similarities in the algorithms used to sove each problem. 

## Cryptographic Applications

Modern cryptography seeks to provide two key things: 1.) *data confidentiality*, and 2.) *data authenticity*. In the asymmetric setting, these goals are achieved via two different processes:

**Asymmetric Encryption:** seeks to hide the contents of a message without data leakage.

**Digital Signatures**: seek to validate a given message as authentic (i.e. from the expected sender).

Despite the competing goals, the underlying algorithms for each process is similar. Moreover, similar to message authentication codes (MACs) in the symmetric setting, digital signatures have an element of compression, such as a hash function, to keep the signature short.

### Encryption: RSA vs ElGamal 

#### Overview

There are two popular algorithms for public key encryption. The first is ElGammal, an algorithm based on Diffie-Hellman key exchanged developed by Taher Elgama in 1985. The second is RSA, which is named after the three scientists that invented it, Ronald Rivest, Adi Shamir, and Leonard Adleman and was granted a US patent in 1983.

Both algorithms are rooted in the number theory concepts summarized above; however, they are fundamentally different. First, security of ElGammal is based on the fact that solving the discrete logarithm problem is hard in certain groups. This is in contrast to RSA, whose security is rooted in the fact that factoring large numbers is difficult. Moreover, the parameters of each algorithm are different, and in general RSA requires less parameters and is more efficient. 

**Neither algorithm achieves semantic security in its most basic form, and must be modified and randomized in order to achieve IND-CPA and IND-CCA security.** 

#### ElGamal

The ElGamal encryption algorithm is as follows:

1. a generator $g$ is selected from a cyclic group $G$ of order $m$. 
2. The receiver randomly selects $x \leftarrow \mathbb{Z}_m$ and computes $X = g^x$. 
3. The sender randomly selects $y \leftarrow \mathbb{Z}_m$ and computes $Y = g^y$. 
4. The send sends $X$ (publically) to the receiver and the receiver sends $Y$ (publically) to the sender. 
5. The receiver computes $K = Y^x$. 
6. The sender computes $K = X^y$. 
7. The sender and receiver can now encrypt and decrypt messages using the same key $K$ as $C = K \cdot M$ and $M = K^{-1} \cdot C$ where $M, C \in G$. 

Note, $K$ will be the same for both the sender and the receiver since $X^y = (g^x)^y= g^{xy} = (g^y)^x = Y^x$. ElGamal has several public parameters, $G, m, g, X, Y$, and two private parameters $x, y$. Its security is rooted in the fact that computing $g^x, g^y, g^{xy}$ is computationally difficult, since it amounts to solving the Computational Diffie-Hellman (CDH) problem. ElGamal can be defined over any cyclic group G, but the generators *and* the messages are elements of $G$. This means that an arbitrary message must either be hashed to a number within the set of $G$, or - more commonly - the scheme is used in conjunction with a symmetric encryption scheme, and only the secret key is encrypted via the ElGamal process (see hybrid encryption below). Note, ElGamal is not IND-CPA under $\mathbb{Z}_p^*$, although it can be IND-CPA under other groups. 

#### RSA

The RSA encryption algorithm is as follows.

1. Receiver generates RSA paramters $(N, e)$ and $(p, q, d)$. $(N, e)$ are public and sent to the Sender, $(p,q,d)$ are private and kept by the Receiver. The following parameter constraints are also implemented:
   1. $ed \pmod{\phi_N} = 1$ for $e,d \in \mathbb{Z}_{\phi_N}$
   2. $N = pq$
   3. $\phi_N = (p-1)(q-1)$ 
2. The Sender encrypts a message $x \in \mathbb{Z}_p^*$ as $C_i = x^e \pmod N$ and sends it to the receiver.
3. The receiver decrypts the message $x = C_i^d \pmod N$ which reduces to x given the follow identies:
   1.  $C_i^d \pmod N = (x^e)^d \pmod N$ 
   2.  $(x^e)^d \pmod N = x^{ed} \pmod N$ 
   3.  $x^{ed} \pmod N = x^{ed \pmod{\phi_N}} \pmod N = x \pmod N$.

The RSA algorithm is fairly efficient, and when used with 1024 bit numbers provides 80 bits of security given modern resources. Often, the encryption exponent is kept small in order to optimize efficiency.

However, there are a few limitations to note. First, the message is a member of $\mathbb{Z}_N^*$, so for a generic plaintext message some processing must be done to map it to a corresponding integer in $Z_N^*$. Moreover, the size of the message is limited by the bitsize of $Z_N^*$, which needs to be kept relatively small for efficiency reasons. This means that RSA encryption is commonly implemented in conjunction with standard symmetric encryption schemes for large messages (see the section on hybrid encryption below). Finally, plain RSA is not semanticially secure, since it is deterministic, and requires additional modifications to provide sematic security.  

**Self Reducibility** of RSA means that:
$$
M_1^e \cdot M_2^e \pmod N = (M_1 \cdot M_2)^e \pmod N,
$$
which means it adheres to normal distributive properties of exponenents. This fact can be exploited for plain RSA to decrypt arbitrary messages. For example, if an algorithm can decrypt $\epsilon$ ciphertexts using $D_s$, where $\epsilon \in [0, 1]$  and $D_s(C_i) = M_i$ for $C_i \in \epsilon \cdot \mathbb{Z}_N^*$, then it can adaptively modify an arbitrary ciphertext until $D_s$ succeeds. For example $R \in \mathbb{Z}_N^*$ then $R^e \cdot C_j, C_j \notin \epsilon \cdot \mathbb{Z}_N^*$, and $R^e \cdot C_J = R^e M_j^e \pmod N = (R\cdot M_j)^e \pmod N$, where $R \cdot M_j$ has a $1/\epsilon$ probability of being decrypted by $D_s$. 

This type of attack motivated early cryptographers to move away from plain RSA, and towards more secure RSA based schemes, described below. 

**Factorization** of RSA alludes to the fact that inverting RSA amounts to factoring the public parameter N. This is because $N=pq$, for 2 prime numbers $p$ and $q$. If an attacker could factor $N$ into $p$ and $q$, then they could determine the order $\phi_N$, which equals $(p-1)(q-1)$ in this case. Knowing $\phi_N$, along with the public exponent $e$, makes the process of decrypting an RSA ciphertext trivial, since the decryption exponent could easily be determined via the following relationship: $ed \pmod{\phi_N} = 1 \pmod{\phi_N}$.   

### Security

**ElGamal** is not semantically secure (IND-CCA) since the ciphertext can be modified without failing decryption. Moreover, it is not IND-CPA secure under $\mathbb{Z}_p^*$ since the Legendre symbols can be exploited to identify the squares in order to distinguish messages, although is does achieve IND-CPA security for subgroups of $Z_p^*$ and for elliptic curve groups. The current standard is to use the (seldom used) Cramar Shoup method, which is semantically secure.

Unfortunately, the Cramar-Shoup algorith requres 2 generators and 5 exponents. It also requires the use of a collision resistant hash function H. While it is IND-CCA for groups where the Decisional Diffie-Hellman problem is hard, it is *rarely* used due to the computational cost of the mutliple exponentiations. 

**Plain RSA** and even modified PKCS#1 RSA (earlier versions) do not provide sufficient semantic security - despite PKCS#1 RSA adding randomness to the RSA algorithm. Plain RSA can be broken via Hastad's broadcast attack and PKCS#1 RSA can be broken via Bleichenbachor's attack. The current RSA standard, RSA-OAEP, is robust to these attacks and provides IND-CCA security under certain theoretical assumptions, specifically that the underlying hash functions $H$ and $G$ act as random oracles. 

Note, RSA-OAEP was invented in 1994, and is currently used by TLS v. 1.0, and 1.1, and SSH v. 1.0 and 2.0.  

## Hybrid Encryption [^3]

In the case of RSA-OAEP, it is computationally and semantically secure; however, it is only designed to encrypt 1024 bits of data, or realistically about 800 bits of data once padding and randomness is accounted for. Moreover, public key protocols leverage number theoretic operations, which are much more inefficient than standard symmetric encryption algorithms. In most cases, *much* larger messages need to be encryption. 

A common solution is to combine a symmetric scheme with an asymmetric scheme, via a method known as hybrid encryption. The sender encrypts the message via a symmetric cryptographic scheme, such as CBC$, and then encrypts the symmetric key with the receiver's asymmetric public key, say RSA-OAEP. The receiver then decrypts the symmetric key first, using their asymetric private key, and then decypts the message via the corresponding symmetric blockcipher scheme.

Hybrid encryption preserves data privacy, while leveraging efficient encryption algorithms in the symmetric setting which can more securely accomodate variable length messages. If both the symmetric and asymmetric schems used are semantically secure, then the hybrid scheme is semantically secure. 

## Citations

[^1]: Smart, N. Cryptography: An Introduction (3rd Edition). Chapter 1.  
[^2]: Bellare, M., Rogaway, P. Introduction to Modern Cryptography. 2005. p. 182

[^3]: Cramer, R., Shoup, V. Design and Analysis of Practical Public Key Encryption Schemes Secure Against Adaptive Ciphertext Attack. https://www.shoup.net/papers/cca2.pdf. 